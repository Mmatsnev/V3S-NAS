#include "stdafx.h"
#include "Lzhuf.h"
#include "crc.h"
#include "Tsdb.h"

/* for decoding */
const BYTE CLzhuf32 :: d_code[256] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
	0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
	0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
	0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
	0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
	0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
	0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
};

const BYTE CLzhuf32 :: d_len[256] = {
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
};

WORD CLzhuf32 :: getbuf = 0;
BYTE CLzhuf32 :: getlen = 0;

CLzhuf32 :: CLzhuf32()
{
	m_pOutBufAutoAlloc = NULL;
}

CLzhuf32::~CLzhuf32()
{
	if( m_pOutBufAutoAlloc )
		delete m_pOutBufAutoAlloc;
	m_pOutBufAutoAlloc = NULL;
}

WORD CLzhuf32 :: GetBit(void)	/* get one bit */
{
	short i;

	while (getlen <= 8)
	{
		if ( (i = ReadOneByte()) < 0 )
			i = 0;
		getbuf |= i << (8 - getlen);
		getlen += 8;
	}
	i = getbuf;
	getbuf <<= 1;
	getlen --;
	return (i < 0);
}

BYTE CLzhuf32 :: GetByte(void)	/* get one byte */
{
	WORD i;
    int  j;

	while (getlen <= 8)
	{
        j = ReadOneByte();
        if ( j < 0 )
			j = 0;
        i = (WORD)j;
		getbuf |= i << (8 - getlen);
		getlen += 8;
	}
	i = getbuf;
	getbuf <<= 8;
	getlen -= 8;
	return ((i >> 8) & 0xff);
}

/* initialization of tree */

void CLzhuf32 :: StartHuff(void)
{
	short int i, j;

	for (i = 0; i < N_CHAR; i++)
	{
		freq[i] = 1;
		son[i] = i + T;
		prnt[i + T] = i;
	}
	i = 0; j = N_CHAR;
	while (j <= R)
	{
		freq[j] = freq[i] + freq[i + 1];
		son[j] = i;
		prnt[i] = prnt[i + 1] = j;
		i += 2; j++;
	}
	freq[T] = 0xffff;
	prnt[R] = 0;
}

/* reconstruction of tree */
void CLzhuf32 :: reconst(void)
{
	short int i, j, k;
	WORD f, l;

	/* collect leaf nodes in the first half of the table */
	/* and replace the freq by (freq + 1) / 2. */
	j = 0;
	for (i = 0; i < T; i++)
	{
		if (son[i] >= T)
		{
			freq[j] = (freq[i] + 1) / 2;
			son[j] = son[i];
			j++;
		}
	}
	/* begin constructing tree by connecting sons */
	for (i = 0, j = N_CHAR; j < T; i += 2, j++)
	{
		k = i + 1;
		f = freq[j] = freq[i] + freq[k];
		for (k = j - 1; f < freq[k]; k--);
		k++;
		l = (j - k) * 2;
		memmove(&freq[k + 1], &freq[k], l);
		freq[k] = f;
		memmove(&son[k + 1], &son[k], l);
		son[k] = i;
	}
	/* connect prnt */
	for (i = 0; i < T; i++)
	{
		if ((k = son[i]) >= T)
		{
			prnt[k] = i;
		}
		else
		{
			prnt[k] = prnt[k + 1] = i;
		}
	}
}

/* increment frequency of given code by one, and update tree */
void CLzhuf32 :: update(short c)
{
	short int i, j, l;
	WORD k;

	if (freq[R] == MAX_FREQ)
	{
            reconst();
	}
	c = prnt[c + T];
	do {
		k = ++freq[c];

		/* if the order is disturbed, exchange nodes */
		if (k > freq[l = c + 1])
		{
			while (k > freq[++l]);
			l--;
			freq[c] = freq[l];
			freq[l] = k;

			i = son[c];
			prnt[i] = l;
			if (i < T)
				prnt[i + 1] = l;

			j = son[l];
			son[l] = i;

			prnt[j] = c;
			if (j < T)
				prnt[j + 1] = c;
			son[c] = j;

			c = l;
		}
	} while ((c = prnt[c]) != 0);	/* repeat up to root */
}

short CLzhuf32 :: DecodeChar(void)
{
	register WORD c;

	c = son[R];

	/* travel from root to leaf, */
	/* choosing the smaller child node (son[]) if the read bit is 0, */
	/* the bigger (son[]+1} if 1 */
	while (c < T)
	{
		c += GetBit();
		c = son[c];
	}
	c -= T;
	update(c);
	return c;
}

short CLzhuf32 :: DecodePosition(void)
{
	WORD i, j, c;

	/* recover upper 6 bits from table */
	i = GetByte();
	c = (WORD)d_code[i] << 6;
	j = d_len[i];

	/* read lower 6 bits verbatim */
	j -= 2;
	while (j--)
	{
	      i = (i << 1) + GetBit();
	}
	return ((c | (i & 0x3f)) & 0xffff);
}

void CLzhuf32 :: Decode(void)  /* recover */
{
	short int i, j, k, r, c;
	register int count;
	int textsize ;

	PrepareData();
	textsize = GetHeader()->m_dwOrgFileLen;				//	压缩前的长度
	if (textsize == 0)
		return;
	StartHuff();
	for (i = 0; i < N - F; i++)
		text_buf[i] = ' ';
	r = N - F;
	for (count = 0; count < textsize; )
	{
		c = DecodeChar();
		if( c < 256 )
		{
			OutputOneByte( (BYTE)c );
			text_buf[r++] = (BYTE)c;
			r &= (N - 1);
			count++;
		}
		else
		{
			i = ( r - DecodePosition() - 1 ) & ( N - 1 );
			j = c - 255 + THRESHOLD;
			for (k = 0; k < j; k++)
			{
				c = text_buf[(i + k) & (N - 1)];
				OutputOneByte( (BYTE)c );
				text_buf[r++] = (BYTE)c;
				r &= (N - 1);
				count++;
			}
		}
	}
}


void CLzhuf32 :: PrepareData()
{
    getbuf = 0;
    getlen = 0;
}

//	将文件附加到 CLzhuf32 对象中
//	入口参数
//		nFileLen				文件长度
//		pBuf					原文件
//	返回参数
//		文件个数
//		0						失败
int CLzhuf32::Attach(int nFileLen, PBYTE pBuf)
{
	CUnCompressObj::Detach();
	if( CUnCompressObj::IsCompress(nFileLen, pBuf) == FALSE )
		return 0;					//	不是压缩文件
	CUnCompressObj::Attach( nFileLen, pBuf );
	return 1;
}

//	取总的文件数
int CLzhuf32::GetFileNum()
{
	if( GetHeader() )
		return 1;
	else
		return 0;					//	没有数据
}

//	解压一个文件
//	入口参数
//		nFileNo					文件序号
//		outfStatus				状态
//		pDstBuf					输出缓冲区
//	返回参数
//		文件缓冲区
//		NULL					失败
//	若 pDstBuf != NULL, 必假设 pDstBuf 长度不小于 outfStatus.m_size
PBYTE CLzhuf32::DecodeOneFile(int nFileNo, CFileStatus &outfStatus, PBYTE pDstBuf)
{
	ASSERT( nFileNo == 0 );						//	因为只有一个文件
	PTSDBCOMPRESSHEAD pHeader = GetHeader();
	ASSERT( pHeader );
	if( CCRC::GetCRC32( pHeader->m_dwFileLen,GetDataBuf() ) != pHeader->m_dwFileCRC32 )
		return NULL;							//	CRC 错误
	SetDstBuffer( pHeader->m_dwOrgFileLen, pDstBuf );		//	设置输出文件缓冲区
	Decode();									//	解压文件
	ASSERT( pHeader->m_dwOrgFileLen == (DWORD)m_nOutDataLen );		//	测试解压是否正确
	ASSERT( pHeader->m_dwOrgFileCRC32 == CCRC::GetCRC32(pHeader->m_dwOrgFileLen,m_pDstDataBuf) );
	m_pOutBufAutoAlloc = ReleaseDstBuffer( outfStatus.m_size );
	if( NULL == pDstBuf )
		return m_pOutBufAutoAlloc;
	m_pOutBufAutoAlloc = NULL;					//	使用外部的内存
	return pDstBuf;
}

//	取一个文件状态
//	入口参数
//		nFileNo					文件序号
//		outfStatus				状态
//	返回参数
//		文件长度
//		0						失败
int CLzhuf32::GetFileInfo(int nFileNo, CFileStatus &outfStatus)
{
	ASSERT( nFileNo == 0 );					//	只支持 1 个文件
	PTSDBCOMPRESSHEAD pHeader = GetHeader();
	ASSERT( pHeader );
	outfStatus.m_szFullName[0] = 0;			//	文件名,属性和时间参见 TSDBFILEHEAD
	outfStatus.m_size = pHeader->m_dwOrgFileLen;
	return pHeader->m_dwOrgFileLen;
}


//	取解压方法常数
DWORD CLzhuf32::GetCompressMethod()
{
	return TSDBCOMPRESS_METHOD_LZHUFV100;
}

//	获取版本号
int CLzhuf32::GetDecoderVersion()
{
	return LZHUF_UNCMP_MAJORVERSION*0x100 + LZHUF_UNCMP_MINORVERSION;
}

//	释放内存
void CLzhuf32::FreeMemory()
{
	if( m_pOutBufAutoAlloc )
		delete m_pOutBufAutoAlloc;
	m_pOutBufAutoAlloc = NULL;
}
